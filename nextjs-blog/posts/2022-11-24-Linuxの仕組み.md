---
title: "Linuxのしくみ 読書メモ"
date: "2022-11-24"
---

# Linuxのしくみ

評判が良かったのと、いい加減一回くらい入門書読まないとなと思ったので流れで買った

## はじめに
この本を読むと下記の事柄が学べる らしいぞ
- カーネルやハードウェアの低レイヤー原因トラブルの解析
- 性能を意識したコーディング
- システムの各種統計情報、チューニングパラメータの意味の理解

[githubにコードがある](https://github.com/satoru-takeuchi/linux-in-practice-2nd)
初期設定もここに書いてある

# 1章 Linuxの概要

- 直接ストレージにアクセスすると、プロセスが書き換え合戦を起こしてやばい
- 間にカーネルを挟んで対応する
- CPUにいくつかモードがある(linuxでは２つ使う）
  - 制限のないカーネルモード
    - カーネルだけがこれで動く
  - 制限をつけられるユーザモード
    - カーネル以外のプロセスはみんなこっち
- システムコールはプロセスがカーネルにカーネルモードでの操作を依頼すること
  - これ以外でカーネルモードの操作をすることはできない

コマンド
- strace
  - システムコールをトレースするやつ？-Oでログを吐く
- sar
  - CPUの処理内容の内訳みたいなのが見える idle100%とか
- taskset
  - 指定したコマンドを指定のCPUで実行する
- ldd
  - ライブラリのリンクを確認する
- dpkg-query
  - ライブラリ検索するのに使ってた

## 監視・アラート・ダッシュボード
今は常に動いてるサーバ持ってないので関係ないけど
そのうち動かすようになったらこのあたりも読めるようにならないと
多分awsとかにも応用が効く

## ライブラリ
OSレベルでライブラリを持っている  
頻繁に使うような処理はココに入る  
linuxはC標準ライブラリ glibc 通称libcが入ってるっぽい  
lddコマンドでライブラリのリンクを確認できる  
echoもcatもpython3もみんな裏ではCを呼んでた

### ラッパー関数
libcにはシステムコールのラッパー関数も入ってる  
システムコールはアセンブリでしか呼べないのでラッパーがないとつらい

- 静的ライブラリ
  - コンパイルの中に含める
- 動的ライブラリ(共有ライブラリ)
  - 呼び出しコードだけ書いておいて、後からライブラリはロードしてくる
- ライセンスまわり調べたときに一回見た話  
  - どちらかだけ許可してたりするので注意しないといけないやつ

- 長らく動的リンクが使われていたが最近は静的リンクが復権しつつあるらしい
- Go言語は静的リンクしかない？らしい
- 容量削減とかが問題じゃなくなった
- dll地獄(updateされると互換性が死ぬやつ)対策など

# ２章 プロセス管理(基礎編)

プロセスが生成されるのは大体２択
1. 同じプログラムの処理を複数のプロセスに分ける
2. 新しいプロセスを生成する

- fork()
  - cloneシステムコールを呼ぶ
  - 新しいメモリ領域に既存のプロセスをコピー
  - copy on write機能のおかげでコストが安いらしい
- execev()
  - execevシステムコールを呼ぶ
  - 既存のメモリ領域を引数の実行プログラムで上書きする
  - コードやデータのサイズ分メモリ領域を確保する(ELFの仕様)

複数に分けるだけならforkだけ、新しく作る場合は両方を使う。

- readelf()
  - エントリポイントとかサイズの情報を見られる
- コード領域とデータ領域とファイル上オフセットについての説明がほしい。
- ``/proc/<pid>/maps``
  - catとかで見るとメモリマップが見える
  - １行目がコード領域で３行目がデータ領域らしい
    - ２行目なんやねんという疑問はある

## ASLR
- Address Space Layout Randomization
- プログラム実行のたびに異なるアドレスにセクション？をマップする仕組み
- ASLRに対応しているプログラムをPosition Independent Executable(PIE)と言う
- 例のgccコンパイル時に-no-pieしたのはわかりやすくするため 基本ONになっていると思って良い
- fileコマンドでPIEかどうかわかる

- POSIX
  - UNIX系OSのC言語インターフェース規格

- pstree -p
  - プロセスの親子関係を木構造で表現してくれる
  - -p はPIDの表示オプション

- ps -aux
  - STARTとTIMEを見ると、利用開始時時間と実際にCPUを使った時間が見える
  - STATがSから始まるとスリープ、Rだと実行可能状態、Zは終了後のゾンビ状態

- wait/waitpid
  - waitシステムコール
  - 終了した子プロセスの情報を得る
  - 実行前に親が死ぬと孤児プロセスになる
    - その時はinitが親になる

## シグナル
- SIGINT = Ctrl + cで送られるやつ
- プロセスのシグナルハンドラがこれを受けて動作を変える
- 他にも色々ある
  - SIGKILL 絶対に殺す
    - しかし殺せないものもある STATがDのやつとか
    - そもそもシグナルを受け付けられない状態らしい

## ジョブ
- ctrl + z を押すとプロセスがバックグラウンドに行く
- この時[1]に入ってて、これがジョブ
- ``jobs``で一覧がだせて、``fg 1``でフォアグラウンド(多分)に戻る

## セッション
- pty/1 みたいなやつ
- ログインセッションのことをセッションと読んでいる。やめろ
- ログイン１つにつきセッション端末も１つある

## デーモン
- セッション端末がない
- 一部のシグナルの解釈が異なる

# 3章 プロセススケジューラ
- １つの論理CPUで実行できるプロセスは１つだけ
- タイムスライスとやらで順番にCPUを使うらしい
- ``time コマンド``
  - real 実時間
  - user ユーザーランドで動作した時間
  - sys カーネルが動作した時間
  - realよりsys+userがでかくなることがある
    - 計算方法の違いや精度の問題
    - 子プロセス作るような処理だとそいつの分も乗る

- 複数論理CPUがある状態だと、ミリ秒単位で交互にCPUを使ってる
  - タイムスライスは時間の単位？

- nice値
  - -20 ~ 19 で表される 低いほどプロセス実行の優先度が高い
  - タイムスライスは可変可能で、割当をある程度操作できる

## コンテキストスイッチ
- タイムスライスが切れるとプロセスが切り替わることを言ってる
- foo()呼び出し後、処理が終わる前にbar()が呼ばれることは十分ありえるということ
- あとはCPUの数に合わせて実行するプロセス数は調節しましょうという感じ
- スループットとターンアラウンドタイムの話
- CPUのシングルスレッド性能があがらなくなってきたので、コアが増えてきた
  - コア数が多い状態に合わせてカーネルなどのソフトも変わっていく

## 4章 メモリ管理システム
読み