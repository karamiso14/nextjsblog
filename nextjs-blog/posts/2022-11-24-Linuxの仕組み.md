---
title: "Linuxのしくみ 読書メモ"
date: "2022-11-24"
---

# Linuxのしくみ

評判が良かったのと、いい加減一回くらい入門書読まないとなと思ったので流れで買った

## はじめに
この本を読むと下記の事柄が学べる らしいぞ
- カーネルやハードウェアの低レイヤー原因トラブルの解析
- 性能を意識したコーディング
- システムの各種統計情報、チューニングパラメータの意味の理解

[githubにコードがある](https://github.com/satoru-takeuchi/linux-in-practice-2nd)
初期設定もここに書いてある

# 1章 Linuxの概要

- 直接ストレージにアクセスすると、プロセスが書き換え合戦を起こしてやばい
- 間にカーネルを挟んで対応する
- CPUにいくつかモードがある(linuxでは２つ使う）
  - 制限のないカーネルモード
    - カーネルだけがこれで動く
  - 制限をつけられるユーザモード
    - カーネル以外のプロセスはみんなこっち
- システムコールはプロセスがカーネルにカーネルモードでの操作を依頼すること
  - これ以外でカーネルモードの操作をすることはできない

コマンド
- strace
  - システムコールをトレースするやつ？-Oでログを吐く
- sar
  - CPUの処理内容の内訳みたいなのが見える idle100%とか
- taskset
  - 指定したコマンドを指定のCPUで実行する
- ldd
  - ライブラリのリンクを確認する
- dpkg-query
  - ライブラリ検索するのに使ってた

## 監視・アラート・ダッシュボード
今は常に動いてるサーバ持ってないので関係ないけど
そのうち動かすようになったらこのあたりも読めるようにならないと
多分awsとかにも応用が効く

## ライブラリ
OSレベルでライブラリを持っている  
頻繁に使うような処理はココに入る  
linuxはC標準ライブラリ glibc 通称libcが入ってるっぽい  
lddコマンドでライブラリのリンクを確認できる  
echoもcatもpython3もみんな裏ではCを呼んでた

### ラッパー関数
libcにはシステムコールのラッパー関数も入ってる  
システムコールはアセンブリでしか呼べないのでラッパーがないとつらい

- 静的ライブラリ
  - コンパイルの中に含める
- 動的ライブラリ(共有ライブラリ)
  - 呼び出しコードだけ書いておいて、後からライブラリはロードしてくる
- ライセンスまわり調べたときに一回見た話  
  - どちらかだけ許可してたりするので注意しないといけないやつ

- 長らく動的リンクが使われていたが最近は静的リンクが復権しつつあるらしい
- Go言語は静的リンクしかない？らしい
- 容量削減とかが問題じゃなくなった
- dll地獄(updateされると互換性が死ぬやつ)対策など

# ２章 プロセス管理(基礎編)

プロセスが生成されるのは大体２択
1. 同じプログラムの処理を複数のプロセスに分ける
2. 新しいプロセスを生成する

- fork()
  - cloneシステムコールを呼ぶ
  - 新しいメモリ領域に既存のプロセスをコピー
  - copy on write機能のおかげでコストが安いらしい
- execev()
  - execevシステムコールを呼ぶ
  - 既存のメモリ領域を引数の実行プログラムで上書きする
  - コードやデータのサイズ分メモリ領域を確保する(ELFの仕様)

複数に分けるだけならforkだけ、新しく作る場合は両方を使う。

- readelf()
  - エントリポイントとかサイズの情報を見られる
- コード領域とデータ領域とファイル上オフセットについての説明がほしい。
- ``/proc/<pid>/maps``
  - catとかで見るとメモリマップが見える
  - １行目がコード領域で３行目がデータ領域らしい
    - ２行目なんやねんという疑問はある

## ASLR
- Address Space Layout Randomization
- プログラム実行のたびに異なるアドレスにセクション？をマップする仕組み
- ASLRに対応しているプログラムをPosition Independent Executable(PIE)と言う
- 例のgccコンパイル時に-no-pieしたのはわかりやすくするため 基本ONになっていると思って良い
- fileコマンドでPIEかどうかわかる

- POSIX
  - UNIX系OSのC言語インターフェース規格

- pstree -p
  - プロセスの親子関係を木構造で表現してくれる
  - -p はPIDの表示オプション

- ps -aux
  - STARTとTIMEを見ると、利用開始時時間と実際にCPUを使った時間が見える
  - STATがSから始まるとスリープ、Rだと実行可能状態、Zは終了後のゾンビ状態

- wait/waitpid
  - waitシステムコール
  - 終了した子プロセスの情報を得る
  - 実行前に親が死ぬと孤児プロセスになる
    - その時はinitが親になる

## シグナル
- SIGINT = Ctrl + cで送られるやつ
- プロセスのシグナルハンドラがこれを受けて動作を変える
- 他にも色々ある
  - SIGKILL 絶対に殺す
    - しかし殺せないものもある STATがDのやつとか
    - そもそもシグナルを受け付けられない状態らしい

## ジョブ
- ctrl + z を押すとプロセスがバックグラウンドに行く
- この時[1]に入ってて、これがジョブ
- ``jobs``で一覧がだせて、``fg 1``でフォアグラウンド(多分)に戻る

## セッション
- pty/1 みたいなやつ
- ログインセッションのことをセッションと読んでいる。やめろ
- ログイン１つにつきセッション端末も１つある

## デーモン
- セッション端末がない
- 一部のシグナルの解釈が異なる

# 3章 プロセススケジューラ
- １つの論理CPUで実行できるプロセスは１つだけ
- タイムスライスとやらで順番にCPUを使うらしい
- ``time コマンド``
  - real 実時間
  - user ユーザーランドで動作した時間
  - sys カーネルが動作した時間
  - realよりsys+userがでかくなることがある
    - 計算方法の違いや精度の問題
    - 子プロセス作るような処理だとそいつの分も乗る

- 複数論理CPUがある状態だと、ミリ秒単位で交互にCPUを使ってる
  - タイムスライスは時間の単位？

- nice値
  - -20 ~ 19 で表される 低いほどプロセス実行の優先度が高い
  - タイムスライスは可変可能で、割当をある程度操作できる

## コンテキストスイッチ
- タイムスライスが切れるとプロセスが切り替わることを言ってる
- foo()呼び出し後、処理が終わる前にbar()が呼ばれることは十分ありえるということ
- あとはCPUの数に合わせて実行するプロセス数は調節しましょうという感じ
- スループットとターンアラウンドタイムの話
- CPUのシングルスレッド性能があがらなくなってきたので、コアが増えてきた
  - コア数が多い状態に合わせてカーネルなどのソフトも変わっていく

# 4章 メモリ管理システム
- ``free``
  - 総メモリと使用中のメモリ量が見られる 直球
  - total - free = used
  - buff/cache + free = available
    - キャッシュは開放すれば使えるから、今は空いてないけど使える判定になるっぽい

- メモリを回収しても足りないときOOM Out Of Memory状態になる
- OOM killer
  - OOMのとき、プロセスを止めてメモリを確保する機能
  - ``dmesg``
    - カーネルログが見られる
    - OOM killerが動いていればここにログが出る

## 仮想記憶
- 仮想記憶が無いとどうなるか
  - メモリの断片化
    - 使用領域の間に小さい空き領域が出てくること
  - マルチプロセスの実現困難
    - 同じメモリ領域を使おうとするのでバッティングする
  - 不正アクセス
    - ほかプロセスが使っている領域にアクセスできてしまう

- プロセスがメモリアクセスするとき、直接アクセスさせない
  - 間接アクセスさせるため、``仮想アドレス``にアクセスさせる
  - 実際のアドレスは``物理アドレス``という
  - アドレスによってアクセス可能な範囲を``アドレス空間``と言う
  - プロセスから直接物理アドレスを操作する方法は無い らしい

- 仮想アドレスと物理アドレスの変換には``ページテーブル``を使う
- カーネルのメモリ内にある
- メモリをページという単位で管理している
- x86_64アーキテクチャなら１ページ4KB?
- ページテーブルの１つのデータのことをページテーブルエントリと呼ぶ
- 仮想アドレス空間外にアクセスすると、CPU上でページフォールトが起こる
  - ページフォールトハンドラでカーネルがSIGSEGVを送る

## 仮想記憶による問題解決
- 断片化したメモリも仮想アドレス上では繋がってるように見せられる
- プロセスごとに異なる物理アドレスを割り当てられる
- 仮想アドレス空間で区切られているので他プロセスのメモリ領域にはアクセスできない
  - 全部解決や

Meltdown脆弱性は、カーネルモードじゃないと見えないカーネルメモリを読み出せる不具合だった

- mmap()システムコール
  - カーネルにメモリを要求する
  - ページテーブルにエントリだけ作る
  - 実際に割り当てるのは、そのメモリ領域にアクセスしたとき
    - ページフォールトが発生するが、未割り当て判定だったら物理メモリをカーネルが割り当てる
    - デマンドページングという

- ページテーブルは階層化されている
  - ある程度まとめないと、莫大なサイズが必要になるため
    - フルに使うと階層型のほうが大きくなるけど、実際そんなことにはならないらしい
  - さらにヒュージページという機能で必要なメモリ量を削減している
    - 階層化をスキップ？して普通にフラットに書いてるようにみえる……
    - 仮想メモリを大量に使うソフトが利用するらしい
      - と思ったら、トラスンペアレントヒューページというのがある
        - いちいち呼ばなくても自動でヒュージ判定をする機能
        - デメリットはあるので最初から有効にはなってないはず
          - ubutnu20.04ではmadvise(システムコールでフラグ設定するとその領域だけ有効になる)設定

# 5章 プロセス管理 応用編
仮想記憶の知識が無いと説明しづらい話が入ってくるらしい。

- fork()再び
  - まずメモリは即コピーされず、ページテーブルだけコピーされる
    - このとき物理アドレスはダブっている状態
    - 書き込み権限が両方消えるらしい
  - 実際に書き込んで初めて物理アドレスが割り当てられる　デマンドページングっぽい動き
    - 書き込もうとするとページフォールトが置きて、カーネルがいい感じに配分する。
  - 関数実行時じゃなく、書き込み時に実際のコピーが走るので**コピーオンライト**と言う
    - CoWとも言うらしい 牛かな
  - RSS(Resident Set Size)
    - プロセスが確保している物理メモリの使用量
    - fork()直後のダブってる状態も計算するので、実際よりでかい数になることがある
- execve()
  - これも同じで、実際にメモリにアクセスするまでは物理メモリが割り当てられない

## プロセス間通信
いっぱい種類あるので一部だけ

- 共有メモリ
  - mmap()システムコールを使う(ここでは？)
  - 保存するときと読むときに専用の書き方をする(コード見てって感じ)
- シグナル
  - SIGUSR1とかSIGUSR2という用途の決まってないシグナルがある
  - シグナルが送れるだけで値は送れないから、これ単体はあんま使えない
- パイプ
  - よくshellで使ってるやつ 確かにプロセス間でデータを受け渡していた
- ソケット
  - 奥が深すぎるので詳しく説明しないらしい
  - UNIXドメインソケット
    - 1つのマシン上のプロセスのみを通信させる
  - TCPソケット、UDPソケット
    - 別マシンとも通信できる、いわゆるインターネットプロトコルスイート
  - UNIXドメインソケットのほうが早いらしい

## 排他制御
aptを同時に動かすとDBが壊れる。わかるね？  
ここではファイルロックを使って説明。

- クリティカルセクション
  - 同時に実行されると困る一連の処理のこと
- アトミック処理
  - システムの外から見て１つの処理に見える一連の処理のこと
    - これ以上小さくできないって意味合いと思われる

- ファイルロックはflock()やfcntl()とかのシステムコールを使う

以下の処理をアトミックに実行する
1. ファイルがロックされているかを確認する
2. ロックされていればシステムコール失敗
3. ロックされていなければロックしてシステムコール成功

- アトミックにするためにロックファイルを用意したのにロックファイルを用意する処理を同時に実行されてしまう問題  
- 排他制御の堂々巡り問題  
- 高級言語だとコストかかるので、CPUレベルで用意されている
- compare and exchange
- compare and swap
- ピーターソンのアルゴリズム
  - とかでググってねって書いてた

## マルチプロセスとマルチスレッド
- マルチプロセスはすでに登場しているfork()やexecve()を使うやつ
  - 必要なプロセスを用意して、プロセス間通信でデータをやり取りして処理するやつ
- マルチスレッドはプロセス内に複数の流れを作る
  - 絵で書いてあるがわかりづれぇ

マルチスレッドの長所
- ページテーブルのコピーが不要、生成時間が短い
- リソースを同じプロセス内の全スレッドで共有、リソース消費が少ない
- 全スレッドがメモリを共有するため、協調動作がしやすい

マルチスレッドの短所
- １つのスレッドが異常終了するとプロセスごと終了する
- スレッドセーフ（マルチスレッドプログラムから呼び出して良い）かどうかを気にしないといけない
  - 排他制御対応されてない処理は危ない。

Goだとgoroutineという言語組み込み機能でスレッドが簡単に扱えるらしいけど頭おいつかなさそう。

この辺よくわかってない
- カーネルスレッド
  - カーネルのメモリ領域内で分かれてる
  - プロセススケジューラでスレッドごとに割当になる
- ユーザスレッド
  - プロセスごとの管理
  - スレッドはカーネルから見えないのでプロセスごとのスケジューラ割当になる
  - goのgoroutineはこっち

# ６章 デバイスアクセス
- 本書ではデバイスファイルを介したアクセスについて述べるらしい
- NICはソケットを使ってるので解説しない
- ブロックデバイス（何それ）のデバイス上に構築したファイルシステムを操作する
  - ファイルシステムは７章にて
- プロセスは直接デバイスにアクセスできないので、カーネルを通す
  - 1章でも書いてた

## デバイスファイル
- デバイスごとにデバイスファイルがある
  - ストレージなら/dev/sdaとか/dev/sdbなど
    - パーティション区切ってるとまたそれぞれに存在する
- プロセス→デバイスファイル(/dev/AAA)→デバイスのデバイスドライバ→デバイス
- デバイスファイルにアクセスできるのはrootだけ
- デバイス固有の複雑な操作にはioctl()というシステムコールを使う
- デバイスファイルには、種類とメジャー番号とマイナー番号が入ってる
  - 歴史的経緯により、番号が一致してれば同じデバイスに対応している。
    - 昔はメジャーがデバイスの種類を識別したりしていたらしいが今はもうないとかなんとか
- 通常/dev/配下にある

## キャラクタデバイス
- 読み出しと書き込みはできる
- アクセスする場所を変更するシーク操作はできない
- 端末、キーボード、マウスなどが該当
  - ``ps ax`` とかするとbashの行にpts/9とかがある
  - dev配下見に行くと存在している
  - echo hello > /dev/pts/9 とかすると、ターミナルに文字が飛び出してくる

## ブロックデバイス
- 読み書きとシークができる
- HDDやSSDのストレージデバイスが該当
- 直接書き込む実験をしてた
  - ぶっ壊れかねないので、ループデバイスを使う方法も紹介
  - ファイルをデバイスファイルのように扱える機能

## デバイスドライバ
- プロセスがデバイスファイルにアクセスした際に動作するカーネル機能
- デバイスを操作するには、内蔵されているレジスタを読み書きする
- CPUのレジスタとは別物 こういうのほんまくそ
- プロセス→デバイスファイル→デバイスドライバ→レジスタ→デバイス
  - 戻るときは逆順で

### メモリマップトI/O(MMIO)
- これを使ってレジスタにアクセスする
- カーネルの仮想アドレス空間にレジスタもマップされる