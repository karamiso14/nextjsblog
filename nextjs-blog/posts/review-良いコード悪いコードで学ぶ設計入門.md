---
title: "良いコード/悪いコードで学ぶ設計入門"
date: "2022-10-07"
---

途中からだけど読んだことをメモっておく

## 13章 モデリング

**特定の目的達成のために最低限考慮が必要な要素を備えたもの**がモデル

商品なら、注文時と配送時で必要な情報が異なる  
注文時には在庫数、配送時に重量とか

クラス設計時にモデル(UML)を作成する作業フローを想定している  
実装を進める中で修正点があればモデルにフィードバックすることで資料としての価値が出てくる  

基本的にはユースケースでユーザの視点から考える  
ただ処理に必要な要素だけでなく、法的視点など様々な観点からモデルを見る  

>本質的課題を解決し、機能性の革新に貢献するモデルをドメイン駆動設計では**深いモデル**と呼びます

詳細は17章のドメイン駆動設計までお預け

モデリングに対しての考え方の事始めという感じ  
実際もっとシステム設計よりの情報とか、システム設計に限らないモデリングの仕方とかを調べてもいいかもしれない  
特に図解やツールについては即使えそうな感じするので調べること候補に入れておく

## 14章 リファクタリング

基本的なことから始まる。リーダブルコード思い出す

- if早期リターン
- !isEnableをisDisable()実装で論理否定減らす
- comic.point > user.point みたいなのをifに直接かかず関数化する

実際のプロダクトコードはもっと複雑、どうすればよいか？

- ユニットテスト
  - 鉄板。
- ファーストクラスコレクション
  - 複雑性の排除目的？
  - Partyクラスの中にmemberListがあって、addとかのメソッドがクラスにまとまっているやつ
- staticメソッドを使わない
  - staticにするとデータ側とメソッドが別クラスに分離しがちだから(多分)
- TDD(だと思うけど明言なし)
  - 仕様がわかっている場合。
  - 仕様がわからない時は
    - 仕様分析方法1-仕様化テスト
      - いろんな引数突っ込んで仕様を探る方法。泥沼。
    - 仕様分析方法2-試行リファクタリング
      - 試しにリポジトリクローンしてリファクタシてみると理解が深まるよ。泥沼。
- IDE機能 例はInteliJ
  - Refactor→Extract Methodマジ便利そう。多分stormにもある。

リファクタリングと機能追加はかならずどちらか一方でやること  
コミットも分けること。原因究明しづらい。  
コミットは違いがわかる単位で。

リスコフの置換原則 基本型を継承型に置き換えても動作できなければならない  
interface切り替えてもちゃんと動くこと。instanceofで分岐とかしてたら意味ない。  
interfaceについては6章を読み直しとくこと。

## 15章 設計の意義と設計への向き合い方

読み
